<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Js를 통한 영상처리 구현 홈페이지</title>

    <script>
        // JavaScript 코딩
        // 전역 변수
        var inCanvas, inCtx, inPaper, inFile; //화면 관련 , 필요한거
        var inImage, inH, inW; // 중요!

        var outCanvas, outCtx, outPaper; //화면 관련 , 필요한거
        var outImage, outH, outW; // 중요!

        var saveImage, saveH, saveW;  // 중요!

        //함수 선언부
        function init() {
            inCanvas = document.getElementById("inCanvas"); // 도화지에 접근
            inCtx = inCanvas.getContext('2d'); // 물감, 붓이 들은 통
            outCanvas = document.getElementById("outCanvas"); // 도화지에 접근
            outCtx = outCanvas.getContext('2d'); // 물감, 붓이 들은 통
        }

        function openImage() {
            inFile = document.getElementById("inFile").files[0]; // Lenna512.raw
            //(중요!) 이미지의 폭과 높이를 계산
            inH = inW = Math.floor(Math.sqrt(inFile.size));
            saveH = inH;
            saveW = inW;

            // 이미지 크기의 2차원 메모리 할당(확보)
            inImage = new Array(inH);
            for (var i = 0; i < inH; i++)
                inImage[i] = new Array(inW);

            saveImage = new Array(saveH);

            for (var i = 0; i < saveH; i++)
                saveImage[i] = new Array(saveW);

            // 캔버스 크기 지정
            inCanvas.height = inH;
            inCanvas.width = inW;

            //파일 --> 메모리로 로딩
            var reader = new FileReader();
            reader.readAsBinaryString(inFile);
            reader.onload = function () {
                var blob = reader.result; // 파일을 한 덩어리(blob)로 가져옴
                // blob에서 한점씩 뽑아서 --> inImage 메모리 (높이 x 폭)
                for (var i = 0; i < inH; i++) {
                    for (var k = 0; k < inW; k++) {
                        var sPixel = (i * inH + k); //시작위치
                        var ePixel = (i * inH + k) + 1; // 끝 위치
                        inImage[i][k] = blob.slice(sPixel, ePixel).charCodeAt(0);  // 아예 읽어올때 꿱뚫 어쩌구 -> 숫자로 읽어옴
                        //자바스크립트 pick 제공 x 자르는것만 제공
                        //slice(0,1) > 0
                    }
                }
                displayImage();



            }

        }

        function displayImage() {
            inPaper = inCtx.createImageData(inH, inW); //빈 종이 준비
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    var px = inImage[i][k]; //'꿱뚫 어쩌고'를 숫자 (예시: 233~) 으로 변경
                    inPaper.data[(i * inH + k) * 4 + 0] = px; // Red
                    inPaper.data[(i * inH + k) * 4 + 1] = px; // Green
                    inPaper.data[(i * inH + k) * 4 + 2] = px; // Blue
                    inPaper.data[(i * inH + k) * 4 + 3] = 255; // Alpha - 투명도
                    //페이퍼에는 4픽셀로 표현됨. 그래서 4 곱하는...
                }
            }
            inCtx.putImageData(inPaper, 0, 0); // 종이를 캔버스 0,0에 붙이기

            outPaper = outCtx.createImageData(outH, outW); //빈 종이 준비
            for (var i = 0; i < outH; i++) {
                for (var k = 0; k < outW; k++) {
                    var px = outImage[i][k]; //'꿱뚫 어쩌고'를 숫자 (예시: 233~) 으로 변경
                    outPaper.data[(i * outH + k) * 4 + 0] = px; // Red
                    outPaper.data[(i * outH + k) * 4 + 1] = px; // Green
                    outPaper.data[(i * outH + k) * 4 + 2] = px; // Blue
                    outPaper.data[(i * outH + k) * 4 + 3] = 255; // Alpha - 투명도
                    //페이퍼에는 4픽셀로 표현됨. 그래서 4 곱하는...
                }
            }
            outCtx.putImageData(outPaper, 0, 0); // 종이를 캔버스 0,0에 붙이기
        }

        // 영상처리 알고리즘 함수부
        function selectAlgo(selNum) {
            switch (parseInt(selNum.value)) {

                // 화소점 case: 100 ~ 107
                case 100: equal_image(); break; //동일 영상
                case 101: add_image(); break;// 여러개중 하나 선택
                case 103: reverse_image(); break;
                case 104: minus_image(); break;
                case 105: blackWhite_image(); break;
                case 106: blackWhite_Aver_image(); break;
                case 107: blackWhite_mid_image(); break;

                // 기하학 case: 201 ~ 205
                case 201: mirror1_image(); break;
                case 202: mirror2_image(); break;
                case 203: zoom_out(); break;
                case 204: zoom_in_forw(); break;
                case 205: zoom_in_backw(); break;


                // Mission case: 300 ~ 305
                case 301: gamma(); break;
                case 302: highlight_Range(); break;
                case 303: p_Cap(); break;
                case 304: p_Cup(); break;
                case 305: move(); break;
                case 306: rotate(); break;

                // Histo case: 401 ~ 400
                case 401: histo_St(); break;
                case 402: endIn(); break;
                case 403: histioEqula_img(); break;

                // 화소 case: 501 ~ 504
                case 501: embos_image(); break;
                case 502: blur_image(); break;
                case 503: edge_image(); break;
                case 504: Log(); break;
                case 505: DoG7x7(); break;
                case 506: homoO(); break;
                case 507: difO(); break;
                case 508: gausian_filter(); break;
            }
        }

        // 화소점 case: 100 ~ 107
        function equal_image() {
            // 중요! 출력 영상의 크기를 계산. 동일영상은 같다.
            outH = inH;
            outW = inW;
            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outW; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;
            //**진짜 영상처리 알고리즘**
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    outImage[i][k] = inImage[i][k];
                }
            }
            displayImage();
        }

        function add_image() {
            // 중요! 출력 영상의 크기를 계산. 동일영상은 같다.
            outH = inH;
            outW = inW;
            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outW; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;
            //**진짜 영상처리 알고리즘**
            var value = parseInt(prompt("밝게하기", "정수값 -->"));
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    if (inImage[i][k] + value + value > 255)
                        outImage[i][k] = 255;
                    else
                        outImage[i][k] = inImage[i][k] + value;
                }
            }
            displayImage();
        }

        function minus_image() { //어둡게
            // 중요! 출력 영상의 크기를 계산.
            outH = inH;
            outW = inW;
            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outW; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;

            //**진짜 영상처리 알고리즘**
            var value = parseInt(prompt("어둡게 하기", "정수값 -->"));
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    if (inImage[i][k] - value < 0)
                        outImage[i][k] = 0;
                    else
                        outImage[i][k] = inImage[i][k] - value;
                }
            }
            displayImage();

        }

        function reverse_image() { //반전
            // 중요! 출력 영상의 크기를 계산.
            outH = inH;
            outW = inW;
            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outW; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;

            //**진짜 영상처리 알고리즘**
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    outImage[i][k] = 255 - inImage[i][k];
                }
            }
            displayImage();

        }

        function minus_image() { //어둡게
            // 중요! 출력 영상의 크기를 계산.
            outH = inH;
            outW = inW;
            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outW; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;

            //**진짜 영상처리 알고리즘**
            var value = parseInt(prompt("어둡게 하기", "정수값 -->"));
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    if (inImage[i][k] - value < 0)
                        outImage[i][k] = 0;
                    else
                        outImage[i][k] = inImage[i][k] - value;
                }
            }
            displayImage();

        }

        function blackWhite_image() { //이진화
            // 중요! 출력 영상의 크기를 계산.
            outH = inH;
            outW = inW;
            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outW; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;

            //**진짜 영상처리 알고리즘**
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    if (inImage[i][k] >= 128)
                        outImage[i][k] = 255;
                    else
                        outImage[i][k] = 0;

                }
            }
            displayImage();

        }

        function blackWhite_Aver_image() { //흑백 평균값
            // 중요! 출력 영상의 크기를 계산.
            outH = inH;
            outW = inW;
            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outW; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;

            //**진짜 영상처리 알고리즘**

            var inImage_sum = 0;

            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++)
                    inImage_sum += inImage[i][k] //여기부터다시보기

            }

            var agerage = inImage_sum / (inH * inW);

            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    if (inImage[i][k] > agerage)
                        outImage[i][k] = 255;
                    else
                        outImage[i][k] = 0;

                }
            }
            displayImage();

        }

        function blackWhite_mid_image() { //흑백 중앙값
            // 중요! 출력 영상의 크기를 계산.
            outH = inH;
            outW = inW;
            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outW; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;

            //**진짜 영상처리 알고리즘**
            // 2차원 배열 > 1차원으로 펼쳐서 중간값 계산

            var tmpArray = new Array(inH * inW); //tmp: 임시값 -> 나중에신경 덜써도됨
            var index = 0;

            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++)
                    tmpArray[index++] = inImage[i][k];
            }

            tmpArray.sort(); //정렬 자동으로 해줌
            var avg_val = tmpArray[parseInt((inH * inW) / 2)];

            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    if (inImage[i][k] > avg_val)
                        outImage[i][k] = 255;
                    else
                        outImage[i][k] = 0;
                }
            }
            displayImage();
        }

        // 기하학 case: 201 ~ 205
        function mirror1_image() { //가로세로 반전
            // 중요! 출력 영상의 크기를 계산. 동일영상은 같다.
            outH = inH;
            outW = inW;
            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outW; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;
            //**진짜 영상처리 알고리즘**
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    outImage[i][inW - 1 - k] = inImage[i][k];
                }
            }
            displayImage();
        }

        function mirror2_image() { //상하미러링
            // 중요! 출력 영상의 크기를 계산. 동일영상은 같다.
            outH = inH;
            outW = inW;
            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outW; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;
            //**진짜 영상처리 알고리즘**
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    outImage[inW - 1 - i][k] = inImage[i][k];
                }
            }
            displayImage();
        }

        function zoom_out() { //줌 아웃, 축소
            var scale = parseInt(prompt("축소배율", 2));
            // 중요! 출력 영상의 크기를 계산. 동일영상은 같다.
            outH = parseInt(inH / scale); //뭐든 깔끔하게 하는게...
            outW = parseInt(inW / scale);
            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outW; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;
            //**진짜 영상처리 알고리즘**
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    outImage[parseInt(i / scale)][parseInt(k / scale)] = inImage[i][k]; // 생긱다시해보기
                }
            }
            displayImage();
        }

        function zoom_in_forw() { //줌인 확대
            var scale = parseInt(prompt("확대배율", 2));
            // 중요! 출력 영상의 크기를 계산. 동일영상은 같다.
            outH = parseInt(inH * scale); //뭐든 깔끔하게 하는게...
            outW = parseInt(inW * scale);
            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outW; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;
            //**진짜 영상처리 알고리즘**
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    outImage[parseInt(i * scale)][parseInt(k * scale)] = inImage[i][k];
                }
            }
            displayImage();
        }

        function zoom_in_backw() { //줌인 - 포워딩 백워딩 기법
            var scale = parseInt(prompt("확대배율", 2));
            // 중요! 출력 영상의 크기를 계산. 동일영상은 같다.
            outH = parseInt(inH * scale);
            outW = parseInt(inW * scale);
            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outW; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;
            //**진짜 영상처리 알고리즘**
            for (var i = 0; i < outH; i++) {
                for (var k = 0; k < outW; k++) {
                    outImage[i][k] = inImage[parseInt(i / scale)][parseInt(k / scale)]; // 생긱다시해보기
                }
            }
            displayImage();
        }

        // Mission case: 300 ~ 305
        function gamma() {
            var gamma_V = prompt("감마 값", 1);
            // 중요! 출력 영상의 크기를 계산. 동일영상은 같다.
            outH = inH;
            outW = inW;
            // 이미지 크기의 2차원 메모리 할당( 확보)
            outImage = new Array(outH);
            for (var i = 0; i < outW; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;
            //**진짜 영상처리 알고리즘**
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    outImage[i][k] = Math.pow(inImage[i][k], 1 / gamma_V);
                }
            }
            displayImage();

        }

        function highlight_Range() {
            var minRange = prompt("작은 범위", 1);
            var maxRange = prompt("큰 범위", 1);

            // 중요! 출력 영상의 크기를 계산. 동일영상은 같다.
            outH = inH;
            outW = inW;
            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outW; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;

            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    if (inImage[i][k] < maxRange && inImage[i][k] > minRange) {
                        outImage[i][k] = 255;
                    }
                    else {
                        outImage[i][k] = inImage[i][k];
                    }

                }
            }
            displayImage();
        }

        function p_Cap() {
            // 중요! 출력 영상의 크기를 계산. 동일영상은 같다.
            outH = inH;
            outW = inW;
            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outW; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;
            //**진짜 영상처리 알고리즘**
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    outImage[i][k] = 255 - 255 * Math.pow((inImage[i][k] / 127 - 1), 2);

                }
            }

            displayImage();

        }

        function p_Cup() {
            // 중요! 출력 영상의 크기를 계산. 동일영상은 같다.
            outH = inH;
            outW = inW;
            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outW; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;
            //**진짜 영상처리 알고리즘**
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    outImage[i][k] = 255 * Math.pow((inImage[i][k] / 127 - 1), 2);

                }
            }

            displayImage();

        }

        function move() {
            var move_x = prompt("이동 x 값", 50);
            var move_y = prompt("이동 y 값", 50);
            // 중요! 출력 영상의 크기를 계산. 동일영상은 같다.
            outH = inH;
            outW = inW;
            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outW; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;
            //**진짜 영상처리 알고리즘**
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    if (k < move_x || i < move_y) {
                        outImage[i][k] = 0;
                    }
                    else
                        outImage[i][k] = inImage[i - move_y][k - move_x];
                }
            }
            displayImage();
        }

        function rotate() { // 생각 더 해보기 흑흑....
            var scale = parseInt(prompt("회전시킬 각도를 입력하세요", 90));
            var radian = scale * (Math.PI / 180);

            outH = inH;
            outW = inW;

            outImage = new Array(outH);
            for (var i = 0; i < outH; i++) {
                outImage[i] = new Array(outW);
            }

            outCanvas.height = outH;
            outCanvas.width = outW;

            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    var centerX = centerY = parseInt(inH / 2);
                    var x = parseInt((i - centerX) * Math.cos(radian) - (k - centerY) * Math.sin(radian) + centerX);
                    var y = parseInt((i - centerX) * Math.sin(radian) + (k - centerY) * Math.cos(radian) + centerY);
                    if ((0 <= x && x <= 255) && (0 <= y && y <= 255)) {
                        outImage[i][k] = inImage[x][y];
                    }
                }
            }
            displayImage();

        }

        // Histo case : 401 ~ 403
        function histo_St() {
            // 중요! 출력 영상의 크기를 계산. 동일영상은 같다.
            outH = inH;
            outW = inW;
            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outW; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;
            //**진짜 영상처리 알고리즘**
            // noutImage = (inImage - low) / (high - low) * 255
            var low = inImage[0][0], high = inImage[0][0];
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    if (inImage[i][k] < low)
                        low = inImage[i][k];
                    if (inImage[i][k] > high)
                        high = inImage[i][k];
                }
            }
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    outImage[i][k] = (inImage[i][k] - low) / (high - low) * 255;
                }
            }
            displayImage();
        }

        function endIn() {
            // 중요! 출력 영상의 크기를 계산. 동일영상은 같다.
            outH = inH;
            outW = inW;
            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outW; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;
            //**진짜 영상처리 알고리즘**
            // noutImage = (inImage - low) / (high - low) * 255
            var low = inImage[0][0], high = inImage[0][0]; // low > 0 이 아님 반복문



            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    if (inImage[i][k] < low)
                        low = inImage[i][k];
                    if (inImage[i][k] > high)
                        high = inImage[i][k];

                }
            }
            low += 50;
            high -= 50;


            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    outImage[i][k] = (inImage[i][k] - low) / (high - low) * 255;
                }

            }
            displayImage();
        }

        function histioEqula_img() { //평활화
            // 중요! 출력 영상의 크기를 계산. 동일영상은 같다.
            outH = inH;
            outW = inW;
            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outW; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;

            //**진짜 영상처리 알고리즘**

            //1단계 : 히스토그램 생성
            var histo = new Array(256); // 0-255 픽셀 값 종류
            for (var i = 0; i < 256; i++) { //초기화
                histo[i] = 0;
            }
            for (var i = 0; i < inH; i++)
                for (var k = 0; k < inW; k++)
                    histo[inImage[i][k]]++;

            // 2단계 : 누적 히스토그램 생ㅎ성
            var sumHisto = new Array(256);
            for (var i = 0; i < outW; i++)
                outImage[i] = new Array(outW);
            var sumValue = 0;
            for (var i = 0; i < 256; i++) {
                sumValue += histo[i];
                sumHisto[i] = sumValue;
            }

            //3단계: 정규화된 누적화
            //nomal[i] = sumHisto[i] * (1/ (inH*inW)) * 255
            var nomalHisto = new Array(256); // 0-255 픽셀 값 종류
            for (var i = 0; i < 256; i++) //초기화
                nomalHisto[i] = 0.0; // 계산은 일단 실수로 해야함. 버그가 잘 생겨서,,, 계산식은 실수로 잡기.
            for (var i = 0; i < 256; i++) {
                nomalHisto[i] = sumHisto[i] * (1.0 / (inH * inW)) * 255.0;
            }
            //최종: 정규화된 히스토그램을 변형시켜서 픽셀값 적용

            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++)
                    outImage[i][k] = parseInt(nomalHisto[inImage[i][k]]);
            }

            displayImage();
        }

        // 화소영역 case : 501 ~ 507
        function embos_image() {
            // 중요! 출력 영상의 크기를 계산
            outH = inH;
            outW = inW;
            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outH; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;
            // ** 진짜 영상처리 알고리즘 **
            // (짱! 중요)
            var mask = [[-1.0, 0.0, 0.0],
            [0.0, 0.0, 0.0],
            [0.0, 0.0, 1.0]];
            // 임시 입력 배열 (입력배열+2)
            var tmpInput = new Array(inH + 2);
            for (var i = 0; i < inH + 2; i++)
                tmpInput[i] = new Array(inW + 2);
            // 임시 입력 배열 초기화(127로)
            for (var i = 0; i < inH + 2; i++)
                for (var k = 0; k < inW + 2; k++)
                    tmpInput[i][k] = 127.0;
            // 원 입력 --> 임시 입력.. 가운데 쏙~
            for (var i = 0; i < inH; i++)
                for (var k = 0; k < inW; k++)
                    tmpInput[i + 1][k + 1] = parseFloat(inImage[i][k]);
            // 임시 출력 배열 (출력배열 크기 동일)
            var tmpOutput = new Array(outH);
            for (var i = 0; i < outH; i++)
                tmpOutput[i] = new Array(outW);
            // **** 회선 연산 ***
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    // 한 점에 대해서 처리
                    var S = 0.0;
                    for (var m = 0; m < 3; m++) {
                        for (var n = 0; n < 3; n++) {
                            S += tmpInput[i + m][k + n] * mask[m][n]
                        }
                    }
                    tmpOutput[i][k] = S;
                }
            }
            // 후처리 :마스크 합계가 0이라면 127 정도를 더하기.
            for (var i = 0; i < outH; i++)
                for (var k = 0; k < outW; k++)
                    tmpOutput[i][k] += 127.0;
            // 임시 출력 --> 원 출력
            for (var i = 0; i < outH; i++)
                for (var k = 0; k < outW; k++)
                    outImage[i][k] = parseInt(tmpOutput[i][k]);
            displayImage();
        }

        function blur_image() {
            // 중요! 출력 영상의 크기를 계산. 동일영상은 같다.
            outH = inH;
            outW = inW;
            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outW; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;
            //**진짜 영상처리 알고리즘**
            // (짱! 중요)
            var mask = [
                [1 / 9., 1 / 9., 1 / 9.],
                [1 / 9., 1 / 9., 1 / 9.],
                [1 / 9., 1 / 9., 1 / 9.]
            ];

            // 임시 입력 배열(입력배열 + 2)
            var tmpInput = new Array(inH + 2);
            for (var i = 0; i < inH + 2; i++)
                tmpInput[i] = new Array(inW + 2);

            //임시 입력 배열 초기화(127로)
            for (var i = 0; i < inH + 2; i++)
                for (var k = 0; k < inW + 2; k++)
                    tmpInput[i][k] = 127.0;

            //원 입력 -> 임시 입력 가운데로
            for (var i = 0; i < inH; i++)
                for (var k = 0; k < inW; k++)
                    tmpInput[i + 1][k + 1] = parseFloat(inImage[i][k]);

            //임시 출력 배열(출력배열 크기 동일 )
            var tmpOutput = new Array(outH);
            for (var i = 0; i < outH; i++)
                tmpOutput[i] = new Array(outW);

            //mask 회선연산
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    var S = 0.0;
                    for (var m = 0; m < 3; m++) {//마스크 행
                        for (var n = 0; n < 3; n++) { //마스크 열
                            S += tmpInput[i + m][k + n] * mask[m][n];
                        }
                    }
                    tmpOutput[i][k] = S;
                }
            }

            //임시 출력 > 원 출력
            for (var i = 0; i < outH; i++)
                for (var k = 0; k < outW; k++)
                    outImage[i][k] = parseInt(tmpOutput[i][k]);
            displayImage();
        }

        function gausian_filter() {
            // 중요! 출력 영상의 크기를 계산. 동일영상은 같다.
            outH = inH;
            outW = inW;
            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outW; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;
            //**진짜 영상처리 알고리즘**
            // (짱! 중요)
            var mask = [
                [1 / 16., 1 / 8., 1 / 16.],
                [1 / 8., 1 / 4., 1 / 8.],
                [1 / 16., 1 / 8., 1 / 16.]
            ];

            // 임시 입력 배열(입력배열 + 2)
            var tmpInput = new Array(inH + 2);
            for (var i = 0; i < inH + 2; i++)
                tmpInput[i] = new Array(inW + 2);

            //임시 입력 배열 초기화(127로)
            for (var i = 0; i < inH + 2; i++)
                for (var k = 0; k < inW + 2; k++)
                    tmpInput[i][k] = 127.0;

            //원 입력 -> 임시 입력 가운데로
            for (var i = 0; i < inH; i++)
                for (var k = 0; k < inW; k++)
                    tmpInput[i + 1][k + 1] = parseFloat(inImage[i][k]);

            //임시 출력 배열(출력배열 크기 동일 )
            var tmpOutput = new Array(outH);
            for (var i = 0; i < outH; i++)
                tmpOutput[i] = new Array(outW);

            //mask 회선연산
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    var S = 0.0;
                    for (var m = 0; m < 3; m++) {//마스크 행
                        for (var n = 0; n < 3; n++) { //마스크 열
                            S += tmpInput[i + m][k + n] * mask[m][n];
                        }
                    }
                    tmpOutput[i][k] = S;
                }
            }

            //임시 출력 > 원 출력
            for (var i = 0; i < outH; i++)
                for (var k = 0; k < outW; k++)
                    outImage[i][k] = parseInt(tmpOutput[i][k]);
            displayImage();
        }

        function edge_image() {
            // 중요! 출력 영상의 크기를 계산
            outH = inH;
            outW = inW;
            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outH; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;
            // ** 진짜 영상처리 알고리즘 **
            // (짱! 중요)
            var mask = [[0., -1., 0.],
            [-1., 2., 0.],
            [0., 0., 0.]];
            // 임시 입력 배열 (입력배열+2)
            var tmpInput = new Array(inH + 2);
            for (var i = 0; i < inH + 2; i++)
                tmpInput[i] = new Array(inW + 2);
            // 임시 입력 배열 초기화(127로)
            for (var i = 0; i < inH + 2; i++)
                for (var k = 0; k < inW + 2; k++)
                    tmpInput[i][k] = 127.0;
            // 원 입력 --> 임시 입력.. 가운데 쏙~
            for (var i = 0; i < inH; i++)
                for (var k = 0; k < inW; k++)
                    tmpInput[i + 1][k + 1] = parseFloat(inImage[i][k]);
            // 임시 출력 배열 (출력배열 크기 동일)
            var tmpOutput = new Array(outH);
            for (var i = 0; i < outH; i++)
                tmpOutput[i] = new Array(outW);
            // **** 회선 연산 ***
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    // 한 점에 대해서 처리
                    var S = 0.0;
                    for (var m = 0; m < 3; m++) {
                        for (var n = 0; n < 3; n++) {
                            S += tmpInput[i + m][k + n] * mask[m][n]
                        }
                    }
                    tmpOutput[i][k] = S;
                }
            }

            // 임시 출력 --> 원 출력
            for (var i = 0; i < outH; i++)
                for (var k = 0; k < outW; k++)
                    outImage[i][k] = parseInt(tmpOutput[i][k]);
            displayImage();
        }

        function Log() {
            // 중요! 출력 영상의 크기를 계산
            outH = inH;
            outW = inW;
            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outH; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;
            // ** 진짜 영상처리 알고리즘 **
            // (짱! 중요)
            var mask = [
                [0., 0., -1., 0., 0.],
                [0., -1., -2., -1., 0.],
                [-1., -2., 16., -2., -1.],
                [0., -1., -2., -1., 0.],
                [0., 0., -1., 0., 0.]

            ];
            // 임시 입력 배열 (입력배열+2)
            var tmpInput = new Array(inH + 4);
            for (var i = 0; i < inH + 4; i++)
                tmpInput[i] = new Array(inW + 4);

            // 임시 입력 배열 초기화(127로)
            for (var i = 0; i < inH + 4; i++)
                for (var k = 0; k < inW + 4; k++)
                    tmpInput[i][k] = 127.0;

            // 원 입력 --> 임시 입력.. 가운데 쏙~
            for (var i = 0; i < inH; i++)
                for (var k = 0; k < inW; k++)
                    tmpInput[i + 1][k + 1] = parseFloat(inImage[i][k]);

            // 임시 출력 배열 (출력배열 크기 동일)
            var tmpOutput = new Array(outH);
            for (var i = 0; i < outH; i++)
                tmpOutput[i] = new Array(outW);

            // **** 회선 연산 ***
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    // 한 점에 대해서 처리
                    var S = 0.0;
                    for (var m = 0; m < 5; m++) {
                        for (var n = 0; n < 5; n++) {
                            S += tmpInput[i + m][k + n] * mask[m][n]
                        }
                    }
                    tmpOutput[i][k] = S;
                }
            }

            // 임시 출력 --> 원 출력
            for (var i = 0; i < outH; i++)
                for (var k = 0; k < outW; k++)
                    outImage[i][k] = parseInt(tmpOutput[i][k]);
            displayImage();
        }

        function DoG7x7() {
            // 중요! 출력 영상의 크기를 계산
            outH = inH;
            outW = inW;
            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outH; i++)
                outImage[i] = new Array(outW);
            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;
            // ** 진짜 영상처리 알고리즘 **
            // (짱! 중요)
            var mask = [
                [0., 0., -1., -1., -1., 0., 0.],
                [0., -2., -3., -3., -3., -2., 0.],
                [-1., -3., 5, 5, 5, -3., -1.],
                [-1., -3., 5, 16, 5, -3., -1.],
                [-1., -3., 5, 5, 5, -3., -1.],
                [0., -2., -3., -3., -3., -2., 0.],
                [0., 0., -1., -1., -1., 0., 0.]
            ];
            // 임시 입력 배열 (입력배열+2)
            var tmpInput = new Array(inH + 6);
            for (var i = 0; i < inH + 6; i++)
                tmpInput[i] = new Array(inW + 6);

            // 임시 입력 배열 초기화(127로)
            for (var i = 0; i < inH + 6; i++)
                for (var k = 0; k < inW + 6; k++)
                    tmpInput[i][k] = 127.0;

            // 원 입력 --> 임시 입력.. 가운데 쏙~
            for (var i = 0; i < inH; i++)
                for (var k = 0; k < inW; k++)
                    tmpInput[i + 1][k + 1] = parseFloat(inImage[i][k]);

            // 임시 출력 배열 (출력배열 크기 동일)
            var tmpOutput = new Array(outH);
            for (var i = 0; i < outH; i++)
                tmpOutput[i] = new Array(outW);

            // **** 회선 연산 ***
            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    // 한 점에 대해서 처리
                    var S = 0.0;
                    for (var m = 0; m < 7; m++) {
                        for (var n = 0; n < 7; n++) {
                            S += tmpInput[i + m][k + n] * mask[m][n]
                        }
                    }
                    tmpOutput[i][k] = S;
                }
            }

            // 임시 출력 --> 원 출력
            for (var i = 0; i < outH; i++)
                for (var k = 0; k < outW; k++)
                    outImage[i][k] = parseInt(tmpOutput[i][k]);

            displayImage();
        }

        function homoO() {
            // 중요! 출력 영상의 크기를 계산
            outH = inH;
            outW = inW;

            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outH; i++)
                outImage[i] = new Array(outW);

            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;

            // ** 진짜 영상처리 알고리즘 **
            // (짱! 중요)

            // 임시 입력 배열 (입력배열+2)
            var tmpInput = new Array(inH + 2);
            for (var i = 0; i < inH + 2; i++)
                tmpInput[i] = new Array(inW + 2);

            // 임시 입력 배열 초기화(127로)
            for (var i = 0; i < inH + 2; i++)
                for (var k = 0; k < inW + 2; k++)
                    tmpInput[i][k] = 127.0;

            // 원 입력 --> 임시 입력.. 가운데 쏙~
            for (var i = 0; i < inH; i++)
                for (var k = 0; k < inW; k++)
                    tmpInput[i + 1][k + 1] = parseFloat(inImage[i][k]);

            // 임시 출력 배열 (출력배열 크기 동일)
            var tmpOutput = new Array(outH);
            for (var i = 0; i < outH; i++)
                tmpOutput[i] = new Array(outW);

            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    max = 0.0;
                    for (var n = 0; n < 3; n++) {
                        for (var m = 0; m < 3; m++) {
                            if (parseInt(tmpInput[i + 1][k + 1] - tmpInput[i + n][k + m]) >= max) {
                                max = parseInt(tmpInput[i + 1][k + 1] - tmpInput[i + n][k + m]);
                            }
                        }
                    }
                    outImage[i][k] = max;
                }

            }
            displayImage();
        }

        function difO() {
            // 중요! 출력 영상의 크기를 계산
            outH = inH;
            outW = inW;

            // 이미지 크기의 2차원 메모리 할당(확보)
            outImage = new Array(outH);
            for (var i = 0; i < outH; i++)
                outImage[i] = new Array(outW);

            // 캔버스 크기 지정
            outCanvas.height = outH;
            outCanvas.width = outW;

            // ** 진짜 영상처리 알고리즘 **
            // (짱! 중요)

            // 임시 입력 배열 (입력배열+2)
            var tmpInput = new Array(inH + 2);
            for (var i = 0; i < inH + 2; i++)
                tmpInput[i] = new Array(inW + 2);

            // 임시 입력 배열 초기화(127로)
            for (var i = 0; i < inH + 2; i++)
                for (var k = 0; k < inW + 2; k++)
                    tmpInput[i][k] = 127.0;

            // 원 입력 --> 임시 입력.. 가운데 쏙~
            for (var i = 0; i < inH; i++)
                for (var k = 0; k < inW; k++)
                    tmpInput[i + 1][k + 1] = parseFloat(inImage[i][k]);

            // 임시 출력 배열 (출력배열 크기 동일)
            var tmpOutput = new Array(outH);
            for (var i = 0; i < outH; i++)
                tmpOutput[i] = new Array(outW);

            for (var i = 0; i < inH; i++) {
                for (var k = 0; k < inW; k++) {
                    max = 0.0; // max 초기화
                    for (var n = 0; n < 3; n++) {
                        for (var m = 0; m < 3; m++) {
                            var d = n * 2 + m; // 제한자.
                            if (d < 3) {
                                if (parseInt(tmpInput[i + n][k + m] - tmpInput[i + (2 - n)][k + (2 - m)]) >= max) {
                                    max = tmpInput[i + n][k + m] - tmpInput[i + (2 - n)][k + (2 - m)];
                                }
                            }
                        }
                    }
                    outImage[i][k] = max;
                }

            }

            displayImage();
        }
    </script>

    <link rel="stylesheet" href="./style.css">
</head>

<body onload="init()" style="text-align:center">

    <div style="padding: 30px ;"></div>

    <header class="title-container">
        <img src="./Title.png" alt="" />
    </header>

    <form>
        <div class="filebox">
            <label for="inFile">
                <img src="./Button.png" alt="파일 등록 버튼" />
            </label>

            <input class="upload-name" value="Only .raw" disabled="disabled" />
            <input type="file" id="inFile" onchange= "openImage()" accept=".raw" />  <br>
        </div>

        <div class="wrap-container">
            <select name="pixel" onchange="selectAlgo(this.form.pixel)">
                <option value=0> 화소점 선택 </option>
                <optgroup herf="#" label="화소점 처리">
                    <option value=100> 동일영상 </option> <!-- 표준으로 사용 가능. 복사해서 쓰기 용이하게 -->
                    <option value=101> 밝게하기 </option> <!-- pixel 값이 101이 넘으면 밝게 하기 -->
                    <option value=103> 반전하기 </option>
                    <option value=104> 어둡게하기 </option>
                    <option value=105> 흑백(128기준) </option>
                    <option value=106> 흑백(평균값 기준) </option>
                    <option value=107> 흑백(중앙값 기준) </option>
                    <option value=301> 감마 </option>
                    <option value=302> 범위강조</option>
                    <option value=303> 파라볼라 캡 </option>
                    <option value=304> 파라볼라 컵 </option>
                </optgroup>
            </select>
            <select name="geometry" onchange="selectAlgo(this.form.geometry)">
                <option value=0> 기하학 선택 </option>
                <optgroup label="기하학 처리">
                    <option value=201> 좌우 미러링 </option>
                    <option value=202> 상하 미러링 </option>
                    <option value=203> 축소 </option>
                    <option value=204> 확대(Forwarding) </option>
                    <option value=205> 확대(Backwording) </option>
                    <option value=305> 이동 </option>
                    <option value=306> 회전 </option>
                </optgroup>
            </select>

            <select name="histogram" onchange="selectAlgo(this.form.histogram)">
                <option value=0> 히스토그램 선택 </option>
                <optgroup label="히스토그램 처리">
                    <option value=401> 히스토 스트레칭</option>
                    <option value=402> 엔드인 탐색</option>
                    <option value=403> 형활화</option>
                </optgroup>
            </select>

            <select name="area" onchange="selectAlgo(this.form.area)">
                <option value=0> 화소영역 선택 </option>
                <optgroup label="화소영역 처리">
                    <option value=501> 엠보싱 </option>
                    <option value=502> 블러링 </option>
                    <option value=508> 가우시안 블러 </option>
                    <option value=503> 경계선 </option>
                    <option value=504> LoG </option>
                    <option value=505> 7X7 DoG </option>
                    <option value=506> 유사 연산 </option>
                    <option value=507> 차 연산 </option>
                </optgroup>
            </select>
        </div>

    </form><br>

    <ul>
        <li class="canvas-container">
            <div class="canvas">
                <canvas id="inCanvas" style="background-color: rgb(202, 202, 202)"> </canvas>
                <p> Before </p>
            </div>

            <div class="canvas">
                <canvas id="outCanvas" style="background-color: rgb(95, 142, 161)"> </canvas> <!-- 캔버스 닫기. 안닫으면 안나옴 -->
                <p> After </p>
            </div>
        </li>
    </ul>

</body>

</html>